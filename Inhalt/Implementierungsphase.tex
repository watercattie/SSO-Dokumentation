% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}

\subsection{Aufsetzen des Grundgerüsts}
\label{sec:AufsetzenGrundgeruest}

Als erstes wurde eine neues Projekt auf dem GitLabServer erstellt und lokal geklont. Über das Terminal wurde auf Basis des MVC Musters ein neues Laravel Projekt mit Authentifizierungserweiterung angelegt. 
Für den Testclient wurde die fertige Instanz des von der Autorin entwickelten Zeiterfassungstool genutzt.

\subsection{Middleware}
\label{sec:Middleware}
Die Middleware bietet einen Filtermechanismus von HTTP-Anfragen, die in eine Anwendung eingehen. Die meist benötigte Middleware wäre hierbei die Überprüfung ob ein User authentifiziert ist. Ist dies nicht der Fall wird er automatisch zum Anmeldebildschirm weitergeleitet. Wenn der Benutzer jedoch authentifiziert ist, ermöglicht die Middleware, dass die Anforderung weiter in der Anwendung ausgeführt wird.

Im Projekt der Autorin werden die Middleware für Authentifizierung sowie der \acs{CSRF}-Schutz (Schutz gegen Anfragenfälschung\footnote{vgl \cite{CSRF}}) genutzt.

\subsection{Implementierung der Benutzeroberfläche}
\label{sec:ImplBenutzeroberflaeche}

Das eingesetzte CSS-Framework Bootstrap ermöglicht ohne Zusatzaufwand eine responsive Darstellung. Die standardisierten Oberflächengestaltungselemente fanden beim Erstellen der Views Anwendung. 
Über die verschiedenen Routen, können Views oder Controllerfunktionen aufgerufen werden. Die Routen können intuitiv benannt werden und werden so in der View aufgerufen.
Unter \ref{app:wyconnect-mockup} finden sich GUI-Ansichten der wichtigsten Views.

\subsection{Implementierung des OAuth2 Flows}
\label{sec:ImplementierungOAuth2}

Mit dem Paketmanager composer wurde das Passport Paket eingebunden, welche den Grundstein des SSO-Servers legt.\footnote{Befehl zur Installation des Pakets: \texttt{composer require laravel/passport} vgl. \cite{composer}} und die erforderlichen Tabellen wurde mit dem laraveleigenen Befehlen migriert. \footnote{Befehl zur Migration: \texttt{php artisan migrate} vgl. \cite{Laravel}}

Es wurde das ORM Modell und auch das Repository Design Pattern umgesetzt. Die Models haben eine zusätzliche  Repository Klasse, die eine Entkapselung der Persistenzschicht mit sich bringt.

Im \Anhang{app:routes} sind alle Routen aufgelistet, die der Server zur Verfügung stellt. Es ist gut zu erkennen, welche Route auf welchen Controller zugreift und wie die Zugriffsrechte über die Middlewares (siehe \fullnameref{sec:Middleware} geregelt sind. Alle Routen mit der Middleware auth können nur eingeloggte User benutzen, guest ist nur für nicht eingeloggte Nutzer offen.

Über ein Formular kann der Admin eines Clients den Namen und die redirect URL angeben und damit seinen Client in die Datenbank eintragen. Als response schickt der ClientController das secret.
Wie üblich beim MVC Muster, leitet die View den Request mit den Clientdaten an den Controller per POST Request, der dann nach Validierung der Daten das Model beauftragt einen neuen Client anzulegen. 

Mit dieser ID und der Redirect Adresse fragt der Client am Server per GET Request einen AuthorizationCode an. Sollte der Benutzer noch nicht eingeloggt sein, schützt die middleware die angeforderte Route und fordert den Nutzer auf sich einzuloggen und leitet in schließlich auf eine View, wo er der Autorisierung der Anwendung zustimmen kann. Die Antwort verarbeiten der \textit{ApproveAuthorizationController} und der \textit{DenyAuthorizationController}, die entweder eine Fehlermeldung zurückgeben, bei fehlerhaftem state Code oder über Passport eigene Funktionen per \textit{completeAuthorizationRequest()} einen AuthCode generieren und ihn per HTTP dem Client als response zusenden.

Mit diesem Code, der ID und dem secret kann der Client letztendlich per HTTP POST Request eine Anfrage auf ein Access Token stellen. Der zuständige Controller validiert die Anfrage und generiert ein Token mit der Passport Funktion \textit{respondToAccessTokenRequest}. Mit diesem Token kann per API und Bearer Autorisierung das Benutzerprofil abgefragt werden.

Die einzelnen Controller, Routen, Models und Views sind im Code Anhang zu finden und sind hier nicht verlinkt. Es wurde auf weitere Spezifizierungen der Sicherheit verzichtet, da das Passport Paket automatisiert alle wichtigen Standards aus dem Internet Engineering Task Force\footnote{vgl \cite{OAuth2}} umsetzt.

\subsection{Implementierung der Anbindung an den Server}
\label{sec:ImplementierungCient}

Wie auch beim SSO-Server wurde beim Client mittels composer das Socialite Paket eingebunden. Um sich mit dem Authentfizierungsserver identifizieren zu können, müssen in die Konfigurationsdatei \textit{config/services.php} die Credentials des Clients eingetragen werden. 

Die ID, sowie das SECRET sind in der \textit{.env} Datei hinterlegt. Nachdem die Routen und Controller fertiggestellt wurden, muss der \textit{WyconnectProvider} implementiert werden. Er setzt die verschiedenen Routen für den Abruf der Auth Codes und Access Tokens, generiert das \textit{state} Feld und handhabt die übergeben Userdaten. 
Im LoginController muss dann nur noch der OAuth2 User aus dem Single-Sign-On in das Usermodel des Clients umgewandelt werden und anschließend eingeloggt werden. 
Als Letztes wurde der Quellcode auf den internen Gitlab Server geladen. In den angebunden Clients muss dann der Gitlab Server als Repository eingebunden werden und anschließend kann das Paket per composer verteilt werden. 
Nach Installation des wy-connect Providers müssen noch die Routen und der LoginController angepasst werden und der Single-Sign-On Mechanismus verlinkt werden. Siehe dazu die Quelltexte im Anhang. 

\Zwischenstand{Implementierungsphase}{Implementierung}
