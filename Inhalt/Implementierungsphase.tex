% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}

\subsection{Aufsetzen des Grundgerüsts}
\label{sec:AufsetzenGrundgeruest}

Als erstes wurde eine neues Projekt auf dem GitLabServer erstellt und lokal geklont. Über das Terminal wurde auf Basis des MVC Musters ein neues Laravel Projekt mit Authentifizierungserweiterung angelegt. 
Für den Testclient wurde die fertige Instanz des von der Autorin entwickelten Zeiterfassungstool genutzt.

\subsection{Middleware}
\label{sec:Middleware}

Middleware bietet einen praktischen Mechanismus zum Filtern von HTTP-Anfragen, die in Ihre Anwendung eingehen. Zum Beispiel enthält Laravel eine Middleware, die überprüft, ob der Benutzer Ihrer Anwendung authentifiziert ist. Wenn der Benutzer nicht authentifiziert ist, leitet die Middleware den Benutzer zum Anmeldebildschirm um. Wenn der Benutzer jedoch authentifiziert ist, ermöglicht die Middleware, dass die Anforderung weiter in der Anwendung ausgeführt wird.

Im Laravel-Framework sind mehrere Middleware enthalten, einschließlich Middleware für Authentifizierung und \acs{CSRF}-Schutz, die die Autorin in ihrem Projekt nutzt. 

\subsection{Implementierung des OAuth2 Flows}
\label{sec:ImplementierungOAuth2}

Mit dem Paketmanager composer wurde das Passport Paket eingebunden, welche den Grundstein des SSO-Servers legt.\footnote{Befehl zur Installation des Pakets: \texttt{composer require laravel/passport} vgl \cite{composer}} und die erforderlichen Tabellen wurde mit dem laraveleigenen Befehlen migriert. \footnote{Befehl zur Migration: \texttt{php artisan migrate} vgl. \cite{Laravel}}

Es wurde das ORM Modell und auch das Repository Design Pattern umgesetzt. Die Models haben eine zusätzliche  Repository Klasse, die eine Entkapselung der Persistenzschicht mit sich bringt.

Im \Anhang{app:routes} sind alle Routen aufgelistet, die der Server zur Verfügung stellt. Es ist sehr schön zu erkennen, welche Route auf welchen Controller zugreift und wie die Zugriffsrechte über die Middlewares (siehe \fullnameref{sec:Middleware} geregelt sind. Alle Routen mit der Middleware web und auth können nur eingeloggte User benutzen, guest ist für alle Nutzer offen.

Nachdem über die View mit Namen und einer URL, auf die der SSO nach Authentifizierung zurück leiten soll, ein neuer Client auf dem Server hinzugefügt wurde, werden die ID und das secret des Clients serverseitig angelegt und dem Client mitgeteilt. Wie üblich beim MVC Muster, leitet die View den Request mit den Clientdaten an den Controller per POST Request, der dann nach Validierung der Daten das Model beauftragt einen neuen Client anzulegen. 

Mit dieser ID und der Redirect Adresse fragt der Client am Server per GET Request einen AuthorizationCode an. Sollte der Benutzer noch nicht eingeloggt sein, schützt die middleware die angeforderte Route und fordert den Nutzer auf sich einzuloggen und leitet in schließlich auf eine View, wo er der Autorisierung der Anwendung zustimmen kann. Der AuthorizationController verarbeitet diese Eingabe und sendet dem Client einen AuthorizationCode. Mit diesem Code, der ID und dem secret kann der Client letztendlich per POST Request eine Anfrage auf ein Access Token stellen. Der zuständige Controller validiert die Anfrage und sendet ein Token zurück. Mit diesem Token kann timy sich 




\subsection{Implementierung der Anbindung an den Server}
\label{sec:ImplementierungCient}


\paragraph{Beispiel}


\Zwischenstand{Implementierungsphase}{Implementierung}
