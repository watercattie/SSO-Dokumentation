% !TEX root = ../Projektdokumentation.tex
\section{Entwurfsphase} 
\label{sec:Entwurfsphase}

\subsection{Zielplattform}
\label{sec:Zielplattform}

Wie in Abschnitt \fullnameref{sec:Projektziel} erwähnt, soll am Ende des Abschlussprojektes eine eigenständige Konsolenanwendung vorliegen. Die Anwendung muss vorerst nur auf Linuxsystemen lauffähig sein, da dies auch die Zielplattform von \textit{syn6} ist.

Als Programmiersprache wurde Scala\footnote{http://www.scala-lang.org} gewählt. Dies bot sich an, da sowohl der Autor, als auch die Backend-Entwickler \textsc{synectic}s mit dieser Sprache bereits vertraut sind. Dies erleichtert später die Wartung des Projektes.

Für das Dateiformat der Regeldateien wurde die \ac{HOCON}\footnote{https://github.com/typesafehub/config/blob/master/HOCON.md} gewählt. Die Nutzwertanalyse, die der Entscheidung für das Dateiformat zugrunde liegt, lässt sich Tabelle~\ref{tab:NutzwertDateiformat} entnehmen. Sowohl für die Gewichtung als auch für die Bewertung der einzelnen Kriterien wurde eine Skala von 1 bis 5 verwendet\footnote{Gewichtung: 1 = unnötig, 5 = unbedingt erforderlich}\footnote{Bewertung: 1 = mangelhaft, 5 = sehr gut}.

\tabelle{Nutzwertanalyse Dateiformat}{tab:NutzwertDateiformat}{NutzwertDateiformat.tex}


\subsection{Architekturdesign}
\label{sec:Architekturdesign}

Um die Abhängigkeiten zwischen den einzelnen Programmkomponenten zu verwalten, wurde das Cake Pattern verwendet\footnote{vgl. http://lampwww.epfl.ch/\textasciitilde odersky/papers/ScalableComponent.pdf}. Beim Cake Pattern werden mithilfe von Scalas Traits Module erstellt, die dann als Mixin in anderen Komponenten verwendet werden können. Ein Vorteil gegenüber den meisten \ac{DI} Frameworks ist, dass hierbei bereits zur Kompilierungszeit festgestellt werden kann, ob alle benötigten Abhängigkeiten erfüllt sind.

Zur Kommunikation mit der zu testenden Datenbank wurde das \textit{Slick} Framework verwendet\footnote{http://slick.typesafe.com/}. Da die Anwendung nur reine \acs{SQL} Queries ausführen muss, und daher kein \ac{ORM} benötigt wird, wird das Slick Framework hauptsächlich als dünner \ac{JDBC}-Wrapper verwendet.

Für das Parsen der Kommandozeilenparameter wurde die Library \textit{scopt}\footnote{https://github.com/scopt/scopt} verwendet. 


\subsection{Entwurf der Benutzeroberfläche}
\label{sec:Benutzeroberflaeche} 

Da die Anwendung automatisiert ausgeführt werden soll, wurde auf eine grafische Benutzeroberfläche verzichtet. Stattdessen soll die Anwendung über die Kommandozeile gestartet werden können. 

Wie bei Kommandozeilenprogrammen üblich, soll ein Hilfetext existieren, der die Syntax, sowie sämtliche Paramter, Optionen und Flags enthält.

Als einzige benötigter Parameter ist der Pfad zur Hauptdatei anzugeben. Zusätzlich soll es möglich sein, den Pfad anzugeben in dem sich die in der Hauptdatei referenzierten Regeldateien befinden und den Pfad der Ergebnisdatei anzupassen. Zuletzt soll ein Flag existieren, dass das Ergebnis nicht in eine Datei speichert, sondern in die Konsole ausgibt. Dies soll es ermöglichen, den Output einer Prüfung direkt in andere Skripte zu pipen um es \zB direkt weiterzuverarbeiten.


\subsection{Datenmodell}
\label{sec:Datenmodell}

Im folgenden sollen die wichtigsten Komponenten des Datenmodells genannt und kurz erläutert werden. Ein vollständiges Komponentendiagramm befindet sich im \Anhang{app:Komponentendiagramm}.

\paragraph{Runner}
Der Runner ist dafür zuständig, auf Grundlage einer Konfigurationsdatei, einen vollständigen Testdurchlauf zu starten. Der Runner selbst besitzt relativ wenig eigene Funktionalität, sondern delegiert stattdessen die einzelnen Aufgaben, wie \zB das Parsen der Regeln und die Ausgabe des Ergebnisses, an die zuständigen Komponenten.

\paragraph{Regel}
Eine Regel repräsentiert eine zu prüfende Bedinung. Es wird hierbei zwischen einfachen und Kompositregeln unterschieden. Beide Arten von Regeln besitzen einen Namen und eine Beschreibung. Eine simple Regel besteht zusätzlich aus einem \acs{SQL}-Query. Dieses Query stellt die Bedingung dar, die durch die Regel validiert werden soll. Eine Kompositregel besitzt kein eigenes Query, sondern stellt eine Verknüpfung aus mehreren anderen Regeln dar. Die verknüpften Regeln können wiederum Kompositregeln sein.

\paragraph{Reporter}
Der Reporter ist für die Ausgabe des Ergebnisses zuständig.


\subsection{Geschäftslogik}
\label{sec:Geschaeftslogik}

Der Ablauf einer Validierung lässt sich in vier Phasen unterteilen:

\paragraph{Einlesen der Hauptdatei}
Die Hauptdatei ist der Ausgangspunkt einer Prüfung. Sie enthält neben sämtlichen auszuführenden Regeln auch alle benötigten Daten für den Verbindungsaufbau mit der zu testenden Datenbank. Ein Beispiel einer solchen Datei findet sich im \Anhang{app:MasterDatei}.

\paragraph{Erstellen der Regeln}
In dieser Phase werden sämtliche Regeln die in der Hauptdatei referenziert sind erstellt. Hierbei wird anhand des Regelnamens die dazugehörige Datei ermittelt und eingelesen. Anschließend wird die Regeldatei geparst und das korrekte Regelobjekt erstellt. Im \Anhang{app:AktivitaetRegelEinlesen} findet sich ein Aktivitätsdiagramm, dass diesen Vorgang beschreibt.

\paragraph{Evaluieren der Regeln}
Nun folgt die eigentliche Prüfung. Die Runner Komponente evaluiert sämtliche Regeln die im vorherigen Schritt erstellt wurden und erstellt daraus ein Ergebnisset.

Die Evaluation einer einfachen Regeln besteht daraus, dass das in der Regeln definierte \acs{SQL}-Query abgesetzt wird. Bei einer Kompositregel werden sämtliche im Komposit definierten Regeln rekursiv evaluiert und anschließend je nach Kompositionsart miteinander verknüpft.

\paragraph{Ergebnisausgabe}
Der letzte Schritt ist die Ausgabe des Gesamtergebnisses. Der Reporter bekommt hierbei die gesamte Ergebnissmenge übergeben und erstellt daraus eine \acs{XML}-Datei.


\subsection{Pflichtenheft/Datenverarbeitungskonzept}
\label{sec:Pflichtenheft}
\begin{itemize}
	\item Auszüge aus dem Pflichtenheft/Datenverarbeitungskonzept, wenn es im Rahmen des Projekts erstellt wurde.
\end{itemize}

\paragraph{Beispiel}
Ein Beispiel für das auf dem Lastenheft (siehe Kapitel~\ref{sec:Lastenheft}: \nameref{sec:Lastenheft}) aufbauende Pflichtenheft ist im \Anhang{app:Pflichtenheft} zu finden.


\Zwischenstand{Entwurfsphase}{Entwurf}
