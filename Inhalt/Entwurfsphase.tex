% !TEX root = ../Projektdokumentation.tex
\section{Entwurfsphase} 
\label{sec:Entwurfsphase}

\subsection{Zielplattform}
\label{sec:Zielplattform}

Wie in Abschnitt \fullnameref{sec:Projektziel} erwähnt, soll am Ende des Abschlussprojektes eine eigenständige Webanwendung vorliegen. Das Deployment und die Aktualisierung wird somit erleichtert.
Die Daten, auf die zugegriffen werden soll, sind in einer bestehenden MySQL Datenbank gespeichert. 

Als Programmiersprache wurde \acs{PHP}\footnote{vgl. \cite{PHP}} gewählt. Dies bot sich an, da viele bestehende Anwendungen bereits in PHP geschrieben sind und sie sich damit leichter an wy-connect anbinden lassen und die Entwickler wycomcos mit dieser Sprache vertraut sind. 
Wie auch die bestehenden Webapplikationen wird bei der Implementation das Framework Laravel\footnote{vgl. \cite{Laravel}} genutzt.

\subsection{Framework}
\label{sec:Framework}

Laravel ist ein freies \acs{PHP}-Webframework, welches dem \acs{MVC}-Muster folgt. 

Es ermöglicht neben dem im folgenden unter \ref{sec:Architekturdesign} erläuterten MVC-Architekturdesign, \acs{REST}-Webdienste zu implementieren.

Laravel wird mit dem \acs{ORM} Eloquent und einem gut bedienbaren Migrationssystem ausgeliefert. Damit werden Objekte einer objektorientierten Anwendung in eine relationale Datenbank überführt.

Das Framework bringt von Hause aus ein Authentifizierungspaket, was auch von wyconnect genutzt wird und durch die Pakete Socialite und Passport ergänzt wird um den OAuth2 Mechanismus zu implementieren. Dazu mehr im Kapitel \fullnameref{sec:Architekturdesign}.

\subsection{Architekturdesign}
\label{sec:Architekturdesign}

Beim Design wurde dem MVC Muster gefolgt, welches Laravel schon mit sich bringt. Die Anwendung wird in 3 Komponenten aufgespalten und sicher damit Flexibilität, Anpassbarkeit und Wiederverwendbarkeit.
Bei einer späteren Implementierung als native Anwendung, kann das Model beibehalten werden und nur die View und der Controller müssten teilweise umgeschrieben werden.

Model
Das Model enthält Daten zur Weiterverarbeitung. In vielen Fällen spiegelt ein Model
eine Tabelle in der Datenbank wieder, so auch beim Eloquent ORM von Laravel. Nur in dieser Model Klasse werden die Daten bearbeitet oder erfasst. Eine Trennung vom Controller ist erwünscht.

View
Die View ist das Benutzerinterface. Daten von Model und Controller werden visualisiert und leitet \zB Benutzeraktionen und Formulare weiter. Innerhalb der View sollte ein Zugriff auf das Model oder den Controller vermieden werden. Somit bleiben alle Daten statisch und werden nicht verändert.

Controller
Der Controller empfängt Anfragen (Requests) von der View. In diesen Request sind \bspw die Login Daten eines Benutzers. Der Controller verarbeitet die Daten und sendet eine Anfrage an das User Model, welches dem Controller den richten User zurückgibt. Dieser loggt den Benutzer ein und die View zeigt den erfolgreichen Login Prozess an. 



\subsection{Entwurf der Benutzeroberfläche}
\label{sec:Benutzeroberflaeche} 

Das Laravel Passport Paket bringt eine beispielhafte Oberfläche mit, in der alle relevanten Anforderungen Anwendung finden. 
Ein Screenshot dazu im \fullnameref{app:wyconnect-mockup}

Über die Hauptansicht kann der Anwender die authorisierten Clients verwalten, sowie deren AccessToken. 

zu exportierenden Ressourcen selektieren und
einschränken können. Folgende Filtermöglichkeiten sollen dafür zur Verfügung stehen:
-Selektion des Ressourcentyps: Auftrags-, Rechnungs- oder Angebotspositionen
-Abfrage der Positionen via Status ; mehrere Auswahlmöglichkeiten
-Abfrage einzelner Auftrags-, Rechnungs- oder Angebotspositionen via Selektion der
Vorgangsnummer ; mehrer Auswahlmöglichkeiten
-Alle Ressourcentyp-Positionen
Das darauf basierende Aktivitätsdiagramm ( zu finden im Anhang unter A.8 ) beschreibt die
Anwender-Interaktion von der Wahl der Ressource, über die Einschränkung dieser, bis zur
Darstellung und Ausgabe der abgefragten Datensätze.
für die Erstellung des Prototyps wurde die kostenlose Diagram-Webanwendung draw.io
genutzt, die dafür die typischen Bootstrap-Komponenten anbietet. Der Entwurf der
Hauptansicht ist im Anhang unter A.7 GUI-Mockup zu finden.
Für die weitere Implementierung des Webinterfaces wurde der Entwurf jedoch nur als grobe
Orientierungsvorlage genutzt, da sich in den Fachgesprächen mit dem Kunden noch
Änderungen ergaben.


\subsection{Datenmodell}
\label{sec:Datenmodell}

Im folgenden sollen die wichtigsten Komponenten des Datenmodells genannt und kurz erläutert werden. Ein vollständiges Komponentendiagramm befindet sich im \Anhang{app:Komponentendiagramm}.

\paragraph{Runner}
Der Runner ist dafür zuständig, auf Grundlage einer Konfigurationsdatei, einen vollständigen Testdurchlauf zu starten. Der Runner selbst besitzt relativ wenig eigene Funktionalität, sondern delegiert stattdessen die einzelnen Aufgaben, wie \zB das Parsen der Regeln und die Ausgabe des Ergebnisses, an die zuständigen Komponenten.

\paragraph{Regel}
Eine Regel repräsentiert eine zu prüfende Bedinung. Es wird hierbei zwischen einfachen und Kompositregeln unterschieden. Beide Arten von Regeln besitzen einen Namen und eine Beschreibung. Eine simple Regel besteht zusätzlich aus einem \acs{SQL}-Query. Dieses Query stellt die Bedingung dar, die durch die Regel validiert werden soll. Eine Kompositregel besitzt kein eigenes Query, sondern stellt eine Verknüpfung aus mehreren anderen Regeln dar. Die verknüpften Regeln können wiederum Kompositregeln sein.

\paragraph{Reporter}
Der Reporter ist für die Ausgabe des Ergebnisses zuständig.


\subsection{Geschäftslogik}
\label{sec:Geschaeftslogik}

Der Ablauf einer Validierung lässt sich in vier Phasen unterteilen:

\paragraph{Einlesen der Hauptdatei}
Die Hauptdatei ist der Ausgangspunkt einer Prüfung. Sie enthält neben sämtlichen auszuführenden Regeln auch alle benötigten Daten für den Verbindungsaufbau mit der zu testenden Datenbank. Ein Beispiel einer solchen Datei findet sich im \Anhang{app:MasterDatei}.

\paragraph{Erstellen der Regeln}
In dieser Phase werden sämtliche Regeln die in der Hauptdatei referenziert sind erstellt. Hierbei wird anhand des Regelnamens die dazugehörige Datei ermittelt und eingelesen. Anschließend wird die Regeldatei geparst und das korrekte Regelobjekt erstellt. Im \Anhang{app:AktivitaetRegelEinlesen} findet sich ein Aktivitätsdiagramm, dass diesen Vorgang beschreibt.

\paragraph{Evaluieren der Regeln}
Nun folgt die eigentliche Prüfung. Die Runner Komponente evaluiert sämtliche Regeln die im vorherigen Schritt erstellt wurden und erstellt daraus ein Ergebnisset.

Die Evaluation einer einfachen Regeln besteht daraus, dass das in der Regeln definierte \acs{SQL}-Query abgesetzt wird. Bei einer Kompositregel werden sämtliche im Komposit definierten Regeln rekursiv evaluiert und anschließend je nach Kompositionsart miteinander verknüpft.

\paragraph{Ergebnisausgabe}
Der letzte Schritt ist die Ausgabe des Gesamtergebnisses. Der Reporter bekommt hierbei die gesamte Ergebnissmenge übergeben und erstellt daraus eine \acs{XML}-Datei.

\subsection{Deployment}
\label{sec:Deployment}

\subsection{Pflichtenheft/Datenverarbeitungskonzept}
\label{sec:Pflichtenheft}
\begin{itemize}
	\item Auszüge aus dem Pflichtenheft/Datenverarbeitungskonzept, wenn es im Rahmen des Projekts erstellt wurde.
\end{itemize}

\paragraph{Beispiel}
Ein Beispiel für das auf dem Lastenheft (siehe Kapitel~\ref{sec:Lastenheft}: \nameref{sec:Lastenheft}) aufbauende Pflichtenheft ist im \Anhang{app:Pflichtenheft} zu finden.


\Zwischenstand{Entwurfsphase}{Entwurf}
